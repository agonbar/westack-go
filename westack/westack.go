package westack

import (
	"encoding/json"
	"fmt"
	swagger "github.com/arsmn/fiber-swagger/v2"
	"github.com/fredyk/westack-go/westack/common"
	"github.com/fredyk/westack-go/westack/datasource"
	"github.com/fredyk/westack-go/westack/model"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/golang-jwt/jwt"
	"go.mongodb.org/mongo-driver/bson"
	"runtime/debug"
	"strings"
	"time"

	// docs are generated by Swag CLI, you have to import them.
	// replace with your own docs folder, usually "github.com/username/reponame/docs"
	//_ "github.com/fredyk/westack-go/docs"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"golang.org/x/crypto/bcrypt"
	"io/ioutil"
	"log"
)

// For HMAC signing method, the key can be any []byte. It is recommended to generate
// a key using crypto/rand or something equivalent. You need the same key for signing
// and validating.
var hmacSampleSecret []byte

type LoginBody struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type WeStack struct {
	ModelRegistry *map[string]*model.Model
	Datasources   *map[string]*datasource.Datasource
	Server        *fiber.App
	Debug         bool
	RestApiRoot   string
	Port          int32

	_swaggerPaths map[string]map[string]interface{}
	init          time.Time
}

func (app WeStack) SwaggerPaths() *map[string]map[string]interface{} {
	return &app._swaggerPaths
}

func (app *WeStack) FindModel(modelName string) *model.Model {
	result := (*app.ModelRegistry)[modelName]
	if result == nil {
		panic(fmt.Sprintf("Model %v not found", modelName))
	}
	return result
}

func (app *WeStack) loadModels() {

	fileInfos, err := ioutil.ReadDir("./common/models")
	if err != nil {
		panic("Error while loading models: " + err.Error())
	}

	var globalModelConfig *map[string]*model.Config
	if err := common.LoadFile("./model-config.json", &globalModelConfig); err != nil {
		panic("Missing or invalid ./model-config.json: " + err.Error())
	}

	app._swaggerPaths = map[string]map[string]interface{}{}
	for _, fileInfo := range fileInfos {

		if strings.Split(fileInfo.Name(), ".")[1] != "json" {
			continue
		}
		var config model.Config
		err := common.LoadFile("./common/models/"+fileInfo.Name(), &config)
		if err != nil {
			panic(err)
		}

		configFromGlobal := (*globalModelConfig)[config.Name]

		if configFromGlobal == nil {
			panic("ERROR: Missing model " + config.Name + " in model-config.json")
		}

		//noinspection GoUnusedVariable
		dataSource := (*app.Datasources)[configFromGlobal.Datasource]

		if dataSource == nil {
			panic(fmt.Sprintf("ERROR: Missing or invalid datasource file for %v", dataSource))
		}

		loadedModel := model.New(config, app.ModelRegistry)
		loadedModel.App = app.AsInterface()
		loadedModel.Datasource = dataSource

		if loadedModel.Config.Public {
			var plural string
			if config.Plural != "" {
				plural = config.Plural
			} else {
				plural = common.DashedCase(config.Name) + "s"
			}
			config.Plural = plural

			modelRouter := app.Server.Group(app.RestApiRoot+"/"+plural, func(ctx *fiber.Ctx) error {
				//log.Println("Resolve " + loadedModel.Name + " " + ctx.Method() + " " + ctx.Path())
				return ctx.Next()
			})
			loadedModel.Router = &modelRouter

			loadedModel.BaseUrl = app.RestApiRoot + "/" + plural
			loadedModel.On("create", func(ctx *model.EventContext) error {

				data := ctx.Data
				if config.Base == "User" {

					if (*data)["email"] == nil || strings.TrimSpace((*data)["email"].(string)) == "" {
						// TODO: Validate email
						return ctx.RestError(fiber.ErrBadRequest, fiber.Map{"error": "Invalid email"})
					}
					filter := map[string]interface{}{"where": map[string]interface{}{"email": (*data)["email"]}}
					existent, err2 := loadedModel.FindOne(&filter)
					if err2 != nil {
						return err2
					}
					if existent != nil {
						return ctx.RestError(fiber.ErrConflict, fiber.Map{"error": "User exists"})
					}

					if (*data)["password"] == nil || strings.TrimSpace((*data)["password"].(string)) == "" {
						return ctx.RestError(fiber.ErrBadRequest, fiber.Map{"error": "Invalid password"})
					}
					hashed, err := bcrypt.GenerateFromPassword([]byte((*data)["password"].(string)), 10)
					if err != nil {
						return err
					}
					(*data)["password"] = string(hashed)

					if app.Debug {
						log.Println("Create User")
					}
				}
				created, err := loadedModel.Create(*data)
				if err != nil {
					return err
				}
				ctx.StatusCode = fiber.StatusOK
				ctx.Result = created.ToJSON()
				return nil
			})

			loadedModel.On("instance_updateAttributes", func(ctx *model.EventContext) error {

				inst, err := loadedModel.FindById(ctx.ModelID, nil)
				if err != nil {
					return err
				}

				if config.Base == "User" && (*ctx.Data)["password"] != nil && (*ctx.Data)["password"] != "" {
					log.Println("Update User")
					hashed, err := bcrypt.GenerateFromPassword([]byte((*ctx.Data)["password"].(string)), 10)
					if err != nil {
						return err
					}
					(*ctx.Data)["password"] = string(hashed)
				}
				updated, err := inst.UpdateAttributes(ctx.Data)
				if err != nil {
					return err
				}
				ctx.StatusCode = fiber.StatusOK
				ctx.Result = updated.ToJSON()
				return nil
			})

			deleteByIdHandler := func(ctx *model.EventContext) error {
				deletedCount, err := loadedModel.DeleteById(ctx.ModelID)
				if err != nil {
					return err
				}
				if deletedCount != 1 {
					return ctx.RestError(fiber.ErrBadRequest, fiber.Map{"error": fmt.Sprintf("Deleted %v instances for %v", deletedCount, ctx.ModelID)})
				}
				ctx.StatusCode = fiber.StatusNoContent
				ctx.Result = ""
				return nil
			}
			loadedModel.On("deleteById", deleteByIdHandler)

			if config.Base == "User" {

				loadedModel.On("login", func(ctx *model.EventContext) error {
					var loginBody *LoginBody
					var data *bson.M
					err := json.Unmarshal(ctx.Ctx.Body(), &loginBody)
					err = json.Unmarshal(ctx.Ctx.Body(), &data)
					if err != nil {
						ctx.StatusCode = fiber.StatusBadRequest
						ctx.Result = fiber.Map{"error": err}
						return err
					}
					ctx.Data = data

					if (*data)["password"] == nil || strings.TrimSpace((*data)["password"].(string)) == "" {
						return ctx.RestError(fiber.ErrBadRequest, fiber.Map{"error": "Invalid password"})
					}

					email := loginBody.Email
					users, err := loadedModel.FindMany(&map[string]interface{}{
						"where": map[string]interface{}{
							"email": email,
						},
					})
					if len(users) == 0 {
						return ctx.RestError(fiber.ErrNotFound, fiber.Map{"error": "User not found"})
					}
					firstUser := users[0]
					ctx.Instance = &firstUser

					firstUserData := firstUser.ToJSON()
					savedPassword := firstUserData["password"]
					err = bcrypt.CompareHashAndPassword([]byte(savedPassword.(string)), []byte(loginBody.Password))
					if err != nil {
						return ctx.RestError(fiber.ErrBadRequest, fiber.Map{"error": "Invalid credentials"})
					}

					userIdHex := firstUser.Id.(primitive.ObjectID).Hex()

					// Create a new token object, specifying signing method and the claims
					// you would like it to contain.
					token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
						"userId":  userIdHex,
						"created": time.Now().UnixMilli(),
					})

					// Sign and get the complete encoded token as a string using the secret
					tokenString, err := token.SignedString(hmacSampleSecret)

					ctx.StatusCode = fiber.StatusOK
					ctx.Result = fiber.Map{"id": tokenString, "userId": userIdHex}
					return nil
				})

			}

		}
	}
}

func handleEvent(eventContext *model.EventContext, loadedModel *model.Model, event string) error {
	err := loadedModel.GetHandler(event)(eventContext)
	if err != nil {
		return loadedModel.SendError(eventContext.Ctx, err)
	}
	if eventContext.StatusCode == 0 {
		eventContext.StatusCode = fiber.StatusNotImplemented
	}
	return eventContext.Ctx.Status(eventContext.StatusCode).JSON(eventContext.Result)
}

func (app *WeStack) loadDataSources() {
	var allDatasources *map[string]*model.DataSourceConfig
	if err := common.LoadFile("./datasources.json", &allDatasources); err != nil {
		panic(err)
	}

	for key, dsConfig := range *allDatasources {
		dsName := dsConfig.Name
		if dsName == "" {
			dsName = key
		}
		if dsConfig.Connector == "mongodb" {
			ds := datasource.New(map[string]interface{}{
				"name":      dsConfig.Name,
				"connector": dsConfig.Connector,
				"database":  dsConfig.Database,
				"url":       fmt.Sprintf("mongodb://%v:%v/%v", dsConfig.Host, dsConfig.Port, dsConfig.Database),
			})
			err := ds.Initialize()
			if err != nil {
				panic(err)
			}
			(*app.Datasources)[dsName] = ds
			if app.Debug {
				log.Println("Connected to database", dsConfig.Database)
			}
		} else {
			panic("ERROR: connector " + dsConfig.Connector + " not supported")
		}
	}
}

func (app *WeStack) Boot(customRoutesCallback func(app *WeStack)) {

	app.loadDataSources()

	app.loadModels()
	app.loadModelsFixedRoutes()

	if customRoutesCallback != nil {
		(customRoutesCallback)(app)
	}

	app.loadModelsDynamicRoutes()
	app.loadNotFoundRoutes()

	app.Server.Get("/swagger/doc.json", func(ctx *fiber.Ctx) error {
		return ctx.JSON(fiber.Map{
			"schemes": []string{"http"},
			"swagger": "2.0",
			"info": fiber.Map{
				"description":    "This is your go-based API Server.",
				"title":          "Swagger API",
				"termsOfService": "http://swagger.io/terms/",
				"contact": fiber.Map{
					"name":  "API Support",
					"url":   "http://www.swagger.io/support",
					"email": "support@swagger.io",
				},
				"license": fiber.Map{
					"name": "Apache 2.0",
					"url":  "http://www.apache.org/licenses/LICENSE-2.0.html",
				},
				"version": "2.0",
			},
			"host":     fmt.Sprintf("127.0.0.1:%v", app.Port),
			"basePath": "/",
			"paths":    app.SwaggerPaths(),
		})
	})

	app.Server.Get("/swagger/*", swagger.Handler) // default
	//app.Server.Get("/swagger*", swagger.NewModel(swagger.ModelConfig{ // custom
	//	URL: "http://localhost:8023/swagger.json",
	//	DeepLinking: false,
	//	// Expand ("list") or Collapse ("none") tag groups by default
	//	DocExpansion: "none",
	//	// Prefill OAuth ClientId on Authorize popup
	//	OAuth: &swagger.OAuthConfig{
	//		AppName:  "OAuth Provider",
	//		ClientId: "21bb4edc-05a7-4afc-86f1-2e151e4ba6e2",
	//	},
	//	// Ability to change OAuth2 redirect uri location
	//	OAuth2RedirectUrl: "http://localhost:8080/swagger/oauth2-redirect.html",
	//}))

}

func (app *WeStack) loadNotFoundRoutes() {
	for _, entry := range *app.ModelRegistry {
		loadedModel := entry
		if !loadedModel.Config.Public {
			if app.Debug {
				log.Println("WARNING: Model", loadedModel.Name, "is not public")
			}
			continue
		}
		(*loadedModel.Router).Use(func(ctx *fiber.Ctx) error {
			log.Println("WARNING: Unresolved method in " + loadedModel.Name + ": " + ctx.Method() + " " + ctx.Path())
			return ctx.Status(404).JSON(fiber.Map{"error": fiber.Map{"status": 404, "message": fmt.Sprintf("Shared class %#v has no method handling %v %v", loadedModel.Name, ctx.Method(), ctx.Path())}})
			//return ctx.Next()
		})
	}
}

func (app *WeStack) AsInterface() *common.IApp {
	return &common.IApp{
		Debug: app.Debug,
		SwaggerPaths: func() *map[string]map[string]interface{} {
			return app.SwaggerPaths()
		},
	}
}

func (app *WeStack) loadModelsFixedRoutes() {
	for _, entry := range *app.ModelRegistry {
		loadedModel := entry
		if !loadedModel.Config.Public {
			if app.Debug {
				log.Println("WARNING: Model", loadedModel.Name, "is not public")
			}
			continue
		}

		if app.Debug {
			log.Println("Mount GET " + loadedModel.BaseUrl)
		}
		loadedModel.RemoteMethod(loadedModel.FindManyRoute, model.RemoteMethodOptions{
			Http: model.RemoteMethodOptionsHttp{
				Path: "/",
				Verb: "get",
			},
		})

		if app.Debug {
			log.Println("Mount POST " + loadedModel.BaseUrl)
		}
		loadedModel.RemoteMethod(func(ctx *fiber.Ctx) error {
			var data *bson.M
			err := json.Unmarshal(ctx.Body(), &data)
			if err != nil {
				return err
			}
			eventContext := model.EventContext{
				Ctx:  ctx,
				Data: data,
			}
			return handleEvent(&eventContext, loadedModel, "create")
		}, model.RemoteMethodOptions{
			Http: model.RemoteMethodOptionsHttp{
				Path: "/",
				Verb: "post",
			},
		})

		if loadedModel.Config.Base == "User" {

			loadedModel.RemoteMethod(func(ctx *fiber.Ctx) error {
				eventContext := model.EventContext{
					Ctx: ctx,
				}
				return handleEvent(&eventContext, loadedModel, "login")
			}, model.RemoteMethodOptions{
				Description: "Logins a user",
				Http: model.RemoteMethodOptionsHttp{
					Path: "/login",
					Verb: "post",
				},
			},
			)

		}

	}
}

func (app *WeStack) loadModelsDynamicRoutes() {
	for _, entry := range *app.ModelRegistry {
		loadedModel := entry
		if !loadedModel.Config.Public {
			if app.Debug {
				log.Println("WARNING: Model", loadedModel.Name, "is not public")
			}
			continue
		}

		if app.Debug {
			log.Println("Mount GET " + loadedModel.BaseUrl + "/:id")
		}
		loadedModel.RemoteMethod(loadedModel.FindByIdRoute, model.RemoteMethodOptions{
			Http: model.RemoteMethodOptionsHttp{
				Path: "/:id",
				Verb: "get",
			},
		})

		if app.Debug {
			log.Println("Mount PATCH " + loadedModel.BaseUrl + "/:id")
		}
		loadedModel.RemoteMethod(func(ctx *fiber.Ctx) error {
			id, err := primitive.ObjectIDFromHex(ctx.Params("id"))
			if err != nil {
				return err
			}
			var data *bson.M
			err = json.Unmarshal(ctx.Body(), &data)
			if err != nil {
				return err
			}
			eventContext := model.EventContext{
				Ctx:     ctx,
				ModelID: &id,
				Data:    data,
			}
			return handleEvent(&eventContext, loadedModel, "instance_updateAttributes")
		}, model.RemoteMethodOptions{
			Http: model.RemoteMethodOptionsHttp{
				Path: "/:id",
				Verb: "patch",
			},
		})

		if app.Debug {
			log.Println("Mount DELETE " + loadedModel.BaseUrl + "/:id")
		}
		loadedModel.RemoteMethod(func(ctx *fiber.Ctx) error {
			id, err := primitive.ObjectIDFromHex(ctx.Params("id"))
			if err != nil {
				return err
			}
			eventContext := model.EventContext{
				Ctx:     ctx,
				ModelID: &id,
			}
			return handleEvent(&eventContext, loadedModel, "deleteById")
		}, model.RemoteMethodOptions{
			Http: model.RemoteMethodOptionsHttp{
				Path: "/:id",
				Verb: "delete",
			},
		})
	}
}

// Listen is an alias for Start()
//
// Deprecated: Start() should be used instead
func (app WeStack) Listen(addr string) interface{} {
	return app.Start(addr)
}

func (app WeStack) Start(addr string) interface{} {
	log.Printf("DEBUG Server took %v ms to start\n", time.Now().UnixMilli()-app.init.UnixMilli())
	return app.Server.Listen(addr)
}

type WeStackOptions struct {
	Debug       bool
	RestApiRoot string
	Port        int32
}

func New(options WeStackOptions) *WeStack {
	server := fiber.New()

	modelRegistry := make(map[string]*model.Model)
	datasources := make(map[string]*datasource.Datasource)

	app := WeStack{
		ModelRegistry: &modelRegistry,
		Server:        server,
		Datasources:   &datasources,
		Debug:         options.Debug,
		RestApiRoot:   options.RestApiRoot,
		Port:          options.Port,

		init: time.Now(),
	}

	// Default middleware config
	server.Use(recover.New(recover.Config{
		EnableStackTrace: true,
		StackTraceHandler: func(e interface{}) {
			log.Println(e)
			debug.PrintStack()
		},
	}))

	return &app
}
